{"version":3,"file":"process-route-tree.js","sources":["../../src/process-route-tree.ts"],"sourcesContent":["import invariant from 'tiny-invariant'\nimport {\n  SEGMENT_TYPE_OPTIONAL_PARAM,\n  SEGMENT_TYPE_PARAM,\n  SEGMENT_TYPE_PATHNAME,\n  parsePathname,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport type { Segment } from './path'\nimport type { RouteLike } from './route'\n\nconst SLASH_SCORE = 0.75\nconst STATIC_SEGMENT_SCORE = 1\nconst REQUIRED_PARAM_BASE_SCORE = 0.5\nconst OPTIONAL_PARAM_BASE_SCORE = 0.4\nconst WILDCARD_PARAM_BASE_SCORE = 0.25\nconst STATIC_AFTER_DYNAMIC_BONUS_SCORE = 0.2\nconst BOTH_PRESENCE_BASE_SCORE = 0.05\nconst PREFIX_PRESENCE_BASE_SCORE = 0.02\nconst SUFFIX_PRESENCE_BASE_SCORE = 0.01\nconst PREFIX_LENGTH_SCORE_MULTIPLIER = 0.0002\nconst SUFFIX_LENGTH_SCORE_MULTIPLIER = 0.0001\n\nfunction handleParam(segment: Segment, baseScore: number) {\n  if (segment.prefixSegment && segment.suffixSegment) {\n    return (\n      baseScore +\n      BOTH_PRESENCE_BASE_SCORE +\n      PREFIX_LENGTH_SCORE_MULTIPLIER * segment.prefixSegment.length +\n      SUFFIX_LENGTH_SCORE_MULTIPLIER * segment.suffixSegment.length\n    )\n  }\n\n  if (segment.prefixSegment) {\n    return (\n      baseScore +\n      PREFIX_PRESENCE_BASE_SCORE +\n      PREFIX_LENGTH_SCORE_MULTIPLIER * segment.prefixSegment.length\n    )\n  }\n\n  if (segment.suffixSegment) {\n    return (\n      baseScore +\n      SUFFIX_PRESENCE_BASE_SCORE +\n      SUFFIX_LENGTH_SCORE_MULTIPLIER * segment.suffixSegment.length\n    )\n  }\n\n  return baseScore\n}\n\nfunction sortRoutes<TRouteLike extends RouteLike>(\n  routes: ReadonlyArray<TRouteLike>,\n): Array<TRouteLike> {\n  const scoredRoutes: Array<{\n    child: TRouteLike\n    trimmed: string\n    parsed: ReadonlyArray<Segment>\n    index: number\n    scores: Array<number>\n    hasStaticAfter: boolean\n    optionalParamCount: number\n  }> = []\n\n  routes.forEach((d, i) => {\n    if (d.isRoot || !d.path) {\n      return\n    }\n\n    const trimmed = trimPathLeft(d.fullPath)\n    let parsed = parsePathname(trimmed)\n\n    // Removes the leading slash if it is not the only remaining segment\n    let skip = 0\n    while (parsed.length > skip + 1 && parsed[skip]?.value === '/') {\n      skip++\n    }\n    if (skip > 0) parsed = parsed.slice(skip)\n\n    let optionalParamCount = 0\n    let hasStaticAfter = false\n    const scores = parsed.map((segment, index) => {\n      if (segment.value === '/') {\n        return SLASH_SCORE\n      }\n\n      if (segment.type === SEGMENT_TYPE_PATHNAME) {\n        return STATIC_SEGMENT_SCORE\n      }\n\n      let baseScore: number | undefined = undefined\n      if (segment.type === SEGMENT_TYPE_PARAM) {\n        baseScore = REQUIRED_PARAM_BASE_SCORE\n      } else if (segment.type === SEGMENT_TYPE_OPTIONAL_PARAM) {\n        baseScore = OPTIONAL_PARAM_BASE_SCORE\n        optionalParamCount++\n      } else {\n        baseScore = WILDCARD_PARAM_BASE_SCORE\n      }\n\n      // if there is any static segment (that is not an index) after a required / optional param,\n      // we will boost this param so it ranks higher than a required/optional param without a static segment after it\n      // JUST FOR SORTING, NOT FOR MATCHING\n      for (let i = index + 1; i < parsed.length; i++) {\n        const nextSegment = parsed[i]!\n        if (\n          nextSegment.type === SEGMENT_TYPE_PATHNAME &&\n          nextSegment.value !== '/'\n        ) {\n          hasStaticAfter = true\n          return handleParam(\n            segment,\n            baseScore + STATIC_AFTER_DYNAMIC_BONUS_SCORE,\n          )\n        }\n      }\n\n      return handleParam(segment, baseScore)\n    })\n\n    scoredRoutes.push({\n      child: d,\n      trimmed,\n      parsed,\n      index: i,\n      scores,\n      optionalParamCount,\n      hasStaticAfter,\n    })\n  })\n\n  const flatRoutes = scoredRoutes\n    .sort((a, b) => {\n      const minLength = Math.min(a.scores.length, b.scores.length)\n\n      // Sort by segment-by-segment score comparison ONLY for the common prefix\n      for (let i = 0; i < minLength; i++) {\n        if (a.scores[i] !== b.scores[i]) {\n          return b.scores[i]! - a.scores[i]!\n        }\n      }\n\n      // If all common segments have equal scores, then consider length and specificity\n      if (a.scores.length !== b.scores.length) {\n        // If different number of optional parameters, fewer optional parameters wins (more specific)\n        // only if both or none of the routes has static segments after the params\n        if (a.optionalParamCount !== b.optionalParamCount) {\n          if (a.hasStaticAfter === b.hasStaticAfter) {\n            return a.optionalParamCount - b.optionalParamCount\n          } else if (a.hasStaticAfter && !b.hasStaticAfter) {\n            return -1\n          } else if (!a.hasStaticAfter && b.hasStaticAfter) {\n            return 1\n          }\n        }\n\n        // If same number of optional parameters, longer path wins (for static segments)\n        return b.scores.length - a.scores.length\n      }\n\n      // Sort by min available parsed value for alphabetical ordering\n      for (let i = 0; i < minLength; i++) {\n        if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n          return a.parsed[i]!.value > b.parsed[i]!.value ? 1 : -1\n        }\n      }\n\n      // Sort by original index\n      return a.index - b.index\n    })\n    .map((d, i) => {\n      d.child.rank = i\n      return d.child\n    })\n\n  return flatRoutes\n}\n\nexport type ProcessRouteTreeResult<TRouteLike extends RouteLike> = {\n  routesById: Record<string, TRouteLike>\n  routesByPath: Record<string, TRouteLike>\n  flatRoutes: Array<TRouteLike>\n}\n\n/**\n * Build lookup maps and a specificity-sorted flat list from a route tree.\n * Returns `routesById`, `routesByPath`, and `flatRoutes`.\n */\n/**\n * Build lookup maps and a specificity-sorted flat list from a route tree.\n * Returns `routesById`, `routesByPath`, and `flatRoutes`.\n */\nexport function processRouteTree<TRouteLike extends RouteLike>({\n  routeTree,\n  initRoute,\n}: {\n  routeTree: TRouteLike\n  initRoute?: (route: TRouteLike, index: number) => void\n}): ProcessRouteTreeResult<TRouteLike> {\n  const routesById = {} as Record<string, TRouteLike>\n  const routesByPath = {} as Record<string, TRouteLike>\n\n  const recurseRoutes = (childRoutes: Array<TRouteLike>) => {\n    childRoutes.forEach((childRoute, i) => {\n      initRoute?.(childRoute, i)\n\n      const existingRoute = routesById[childRoute.id]\n\n      invariant(\n        !existingRoute,\n        `Duplicate routes found with id: ${String(childRoute.id)}`,\n      )\n\n      routesById[childRoute.id] = childRoute\n\n      if (!childRoute.isRoot && childRoute.path) {\n        const trimmedFullPath = trimPathRight(childRoute.fullPath)\n        if (\n          !routesByPath[trimmedFullPath] ||\n          childRoute.fullPath.endsWith('/')\n        ) {\n          routesByPath[trimmedFullPath] = childRoute\n        }\n      }\n\n      const children = childRoute.children as Array<TRouteLike>\n\n      if (children?.length) {\n        recurseRoutes(children)\n      }\n    })\n  }\n\n  recurseRoutes([routeTree])\n\n  const flatRoutes = sortRoutes(Object.values(routesById))\n\n  return { routesById, routesByPath, flatRoutes }\n}\n"],"names":["i"],"mappings":"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"}